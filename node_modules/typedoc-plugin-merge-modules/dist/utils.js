import { DeclarationReflection, ReflectionKind, } from "typedoc";
/**
 * Tries to determine the original name of a reflection.
 * @param context The TypeDoc context.
 * @param reflection The reflection whose original name is wanted.
 * @returns The original name of the reflection or undefined if it could not be determined.
 */
export function tryGetOriginalReflectionName(context, reflection) {
    var _a, _b;
    const symbol = context.project.getSymbolFromReflection(reflection);
    if (symbol) {
        if (symbol.name && symbol.name !== "default") {
            return symbol.name;
        }
        else if (symbol.declarations) {
            const declaration = symbol.declarations[0];
            const declarationName = (_b = (_a = declaration === null || declaration === void 0 ? void 0 : declaration.name) === null || _a === void 0 ? void 0 : _a.getText) === null || _b === void 0 ? void 0 : _b.call(_a);
            if (typeof declarationName === "string") {
                return declarationName;
            }
        }
    }
    return undefined;
}
/**
 * Removes a possible tag from the comments of the given reflection.
 * @param reflection The reflection from which the tag should be removed.
 * @param tagToRemove Name of the tag to be removed.
 */
export function removeTagFromCommentsOf(reflection, tagToRemove) {
    var _a, _b, _c;
    const tagIndex = (_b = (_a = reflection.comment) === null || _a === void 0 ? void 0 : _a.blockTags.findIndex((ct) => ct.tag === tagToRemove)) !== null && _b !== void 0 ? _b : -1;
    if (tagIndex !== -1) {
        (_c = reflection.comment) === null || _c === void 0 ? void 0 : _c.blockTags.splice(tagIndex, 1);
    }
}
/**
 * Adds the given declaration reflection to the given target.
 * @param ref The declaration reflection which should be added to the target.
 * @param target The target to which to add the declaration reflection.
 */
export function addDeclarationReflectionToTarget(ref, target) {
    var _a, _b;
    ref.parent = target;
    (_a = target.children) === null || _a === void 0 ? void 0 : _a.push(ref);
    (_b = target.childrenIncludingDocuments) === null || _b === void 0 ? void 0 : _b.push(ref);
}
/**
 * Removes the given declaration reflection from its module.
 * @param ref The declaration reflection which should be removed from its module.
 * @throws {Error} If the given reflection is not within a module.
 */
export function removeDeclarationReflectionFromModule(ref) {
    var _a, _b, _c, _d, _e, _f;
    const module = ref.parent;
    if (!(module instanceof DeclarationReflection)) {
        throw new Error("Trying to move a declaration reflection that is not part of a module");
    }
    const indexInChildren = (_b = (_a = module.children) === null || _a === void 0 ? void 0 : _a.indexOf(ref)) !== null && _b !== void 0 ? _b : -1;
    if (indexInChildren !== -1) {
        (_c = module.children) === null || _c === void 0 ? void 0 : _c.splice(indexInChildren, 1);
    }
    const indexInChildrenIncludingDocuments = (_e = (_d = module.childrenIncludingDocuments) === null || _d === void 0 ? void 0 : _d.indexOf(ref)) !== null && _e !== void 0 ? _e : -1;
    if (indexInChildrenIncludingDocuments !== -1) {
        (_f = module.childrenIncludingDocuments) === null || _f === void 0 ? void 0 : _f.splice(indexInChildrenIncludingDocuments, 1);
    }
}
/**
 * Adds the given document reflection to the given target.
 * @param ref The document reflection which should be added to the target.
 * @param target The target to which to add the document reflection.
 */
export function addDocumentReflectionToTarget(ref, target) {
    var _a, _b;
    ref.parent = target;
    (_a = target.documents) === null || _a === void 0 ? void 0 : _a.push(ref);
    (_b = target.childrenIncludingDocuments) === null || _b === void 0 ? void 0 : _b.push(ref);
}
/**
 * Removes the given document reflection from its module.
 * @param ref The document reflection which should be removed from its module.
 * @throws {Error} If the given reflection is not within a module.
 */
export function removeDocumentReflectionFromModule(ref) {
    var _a, _b, _c, _d, _e, _f;
    const module = ref.parent;
    if (!(module instanceof DeclarationReflection)) {
        throw new Error("Trying to move a document reflection that is not part of a module");
    }
    const indexInDocuments = (_b = (_a = module.documents) === null || _a === void 0 ? void 0 : _a.indexOf(ref)) !== null && _b !== void 0 ? _b : -1;
    if (indexInDocuments !== -1) {
        (_c = module.documents) === null || _c === void 0 ? void 0 : _c.splice(indexInDocuments, 1);
    }
    const indexInChildrenIncludingDocuments = (_e = (_d = module.childrenIncludingDocuments) === null || _d === void 0 ? void 0 : _d.indexOf(ref)) !== null && _e !== void 0 ? _e : -1;
    if (indexInChildrenIncludingDocuments !== -1) {
        (_f = module.childrenIncludingDocuments) === null || _f === void 0 ? void 0 : _f.splice(indexInChildrenIncludingDocuments, 1);
    }
}
/**
 * Moves a declaration reflection to the given target.
 * @param ref The declaration reflection that should be moved.
 * @param target The target into which the declaration reflection should be moved.
 */
export function moveDeclarationReflectionToTarget(ref, target) {
    removeDeclarationReflectionFromModule(ref);
    addDeclarationReflectionToTarget(ref, target);
}
/**
 * Moves a document reflection to the given target.
 * @param ref The document reflection that should be moved.
 * @param target The target into which the document reflection should be moved.
 */
export function moveDocumentReflectionToTarget(ref, target) {
    removeDocumentReflectionFromModule(ref);
    addDocumentReflectionToTarget(ref, target);
}
/**
 * Returns the modules within the given module parent. Searches recursively.
 * @param moduleParent The element in which to search for modules.
 * @returns The modules within the given module parent.
 */
export function getModulesFrom(moduleParent) {
    var _a;
    const modules = ((_a = moduleParent.children) !== null && _a !== void 0 ? _a : []).filter((c) => c.kindOf(ReflectionKind.Module));
    for (const mod of modules) {
        const subModules = getModulesFrom(mod);
        modules.push(...subModules);
    }
    return modules;
}
/**
 * Returns the first line of the given string.
 * @param text The string from which to read the first line.
 * @returns The first line of the given string.
 */
function getFirstLineOf(text) {
    return text.split("\n", 1)[0];
}
/**
 * Returns the name of the given description tag.
 * @param tag The description tag.
 * @returns The name of the given description tag.
 */
export function getNameFromDescriptionTag(tag) {
    var _a, _b;
    return getFirstLineOf((_b = (_a = tag.content[0]) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : "");
}
