import { Comment, DeclarationReflection, DocumentReflection, ReflectionKind } from "typedoc";
import { getNameFromDescriptionTag, moveDeclarationReflectionToTarget, moveDocumentReflectionToTarget, removeTagFromCommentsOf, } from "../utils.js";
/**
 * Name of the comment tag that can be used to mark a module as the target module within the bundle.
 * The target module is the one into which all the modules of the bundle are merged.
 */
const targetModuleCommentTag = "@mergeTarget";
/**
 * Class representing a group of modules.
 */
export class ModuleBundle {
    /**
     * Creates a new module bundle instance.
     * @param project The project in which all modules are in.
     */
    constructor(project) {
        /** The modules of the bundle. */
        this.modules = new Array();
        this.project = project;
    }
    /**
     * Adds a module to the bundle.
     * @param module The module to add.
     */
    add(module) {
        this.modules.push(module);
    }
    /**
     * Merges the modules of the bundle into one module (or the given target override).
     * @param categorizationHasAlreadyHappened Defines if TypeDoc has already categorized the
     *                                         reflections in the modules of the bundle.
     * @param targetOverride A module to target, taking precendence over the bundle's search.
     */
    merge(categorizationHasAlreadyHappened, targetOverride) {
        // get target module
        const mergeTarget = targetOverride !== null && targetOverride !== void 0 ? targetOverride : this.getTargetModule();
        removeTagFromCommentsOf(mergeTarget, targetModuleCommentTag);
        this.moveChildrenAndDocumentsIntoTarget(mergeTarget);
        if (categorizationHasAlreadyHappened) {
            // In this case TypeDoc has already categorized and grouped the reflections.
            // Therefore we must copy the content of all categories and groups into the target.
            this.moveCategoriesIntoTarget(mergeTarget);
            this.moveGroupsIntoTarget(mergeTarget);
        }
        else {
            // In this case we must copy the category descriptions into the target because TypeDoc will look
            // for them there when it categorizes and groups the reflections.
            // If we don't do this then the category and group descriptions will be missing in the docs.
            this.copyCategoryDescriptionTagsIntoTarget(mergeTarget);
            this.copyGroupDescriptionTagsIntoTarget(mergeTarget);
        }
        // remove rest modules
        this.modules.forEach((module) => {
            if (module !== mergeTarget) {
                delete module.children;
                this.project.removeReflection(module);
            }
        });
    }
    /**
     * Returns the module from the bundle that should be used as the target module.
     * @returns The target module.
     */
    getTargetModule() {
        // 1. search for the first module which is marked with a specific tag
        const firstModuleWithTargetTag = this.modules.find((module) => module.comment && module.comment.blockTags.findIndex((ct) => ct.tag === targetModuleCommentTag) !== -1);
        if (firstModuleWithTargetTag) {
            return firstModuleWithTargetTag;
        }
        // 2. search for the first module with a comment
        const firstModuleWithComment = this.modules.find((module) => { var _a, _b; return ((_b = (_a = module.comment) === null || _a === void 0 ? void 0 : _a.summary.length) !== null && _b !== void 0 ? _b : 0) > 0; });
        if (firstModuleWithComment) {
            return firstModuleWithComment;
        }
        // 3. default: pick the first module
        return this.modules[0];
    }
    /**
     * Moves all children and documents into the given target.
     * @param target The target into which the children and documents should be moved.
     */
    moveChildrenAndDocumentsIntoTarget(target) {
        var _a;
        for (const mod of this.modules) {
            // Here we create a copy because the next loop modifies the collection
            const reflections = [...((_a = mod.childrenIncludingDocuments) !== null && _a !== void 0 ? _a : [])];
            for (const ref of reflections) {
                // Drop aliases (= ReflectionKind.Reference)
                if (ref instanceof DeclarationReflection && !ref.kindOf(ReflectionKind.Reference)) {
                    moveDeclarationReflectionToTarget(ref, target);
                }
                else if (ref instanceof DocumentReflection) {
                    moveDocumentReflectionToTarget(ref, target);
                }
            }
        }
    }
    /**
     * Moves the children from all modules' categories into the corresponding category of the given target.
     * @param target The target into whose categories the children should be moved.
     */
    moveCategoriesIntoTarget(target) {
        var _a;
        // move categories
        this.modules.forEach((module) => {
            var _a;
            if (module !== target) {
                (_a = module.categories) === null || _a === void 0 ? void 0 : _a.forEach((category) => {
                    var _a, _b, _c;
                    const existingTargetCategory = (_a = target.categories) === null || _a === void 0 ? void 0 : _a.find((c) => c.title === category.title);
                    if (!existingTargetCategory) {
                        target.categories = [...((_b = target.categories) !== null && _b !== void 0 ? _b : []), category];
                    }
                    else {
                        existingTargetCategory.children = existingTargetCategory.children.concat(category.children);
                        if (((_c = existingTargetCategory.description) === null || _c === void 0 ? void 0 : _c.length) === 0 && category.description) {
                            existingTargetCategory.description = category.description;
                        }
                    }
                });
            }
        });
        // sort categories
        (_a = target.categories) === null || _a === void 0 ? void 0 : _a.forEach((category) => {
            category.children.sort((a, b) => {
                if (a.name > b.name) {
                    return 1;
                }
                else if (a.name === b.name) {
                    return 0;
                }
                return -1;
            });
        });
    }
    /**
     * Copies the category description comment tags into the the given target.
     * @param target The target into which the category descriptions are copied.
     */
    copyCategoryDescriptionTagsIntoTarget(target) {
        this.modules.forEach((module) => {
            var _a, _b;
            if (module !== target) {
                const categoryDescriptionsOfModule = (_b = (_a = module.comment) === null || _a === void 0 ? void 0 : _a.blockTags.filter((bt) => bt.tag === "@categoryDescription")) !== null && _b !== void 0 ? _b : [];
                if (categoryDescriptionsOfModule.length === 0) {
                    return; // nothing to copy
                }
                if (!target.comment) {
                    target.comment = new Comment([], []);
                }
                categoryDescriptionsOfModule.forEach((categoryDescription) => {
                    var _a, _b;
                    const targetModuleAlreadyHasThisCategoryDescriptionsTag = (_a = target.comment) === null || _a === void 0 ? void 0 : _a.blockTags.find((bt) => bt.tag === "@categoryDescription" &&
                        getNameFromDescriptionTag(bt) === getNameFromDescriptionTag(categoryDescription));
                    if (!targetModuleAlreadyHasThisCategoryDescriptionsTag) {
                        (_b = target.comment) === null || _b === void 0 ? void 0 : _b.blockTags.push(categoryDescription);
                    }
                });
            }
        });
    }
    /**
     * Moves the children from all modules' groups into the corresponding group of the given target.
     * @param target The target into whose groups the children should be moved.
     */
    moveGroupsIntoTarget(target) {
        var _a;
        // move groups
        this.modules.forEach((module) => {
            var _a;
            if (module !== target) {
                (_a = module.groups) === null || _a === void 0 ? void 0 : _a.forEach((group) => {
                    var _a, _b, _c;
                    const existingTargetGroup = (_a = target.groups) === null || _a === void 0 ? void 0 : _a.find((g) => g.title === group.title);
                    if (!existingTargetGroup) {
                        target.groups = [...((_b = target.groups) !== null && _b !== void 0 ? _b : []), group];
                    }
                    else {
                        existingTargetGroup.children = existingTargetGroup.children.concat(group.children);
                        if (((_c = existingTargetGroup.description) === null || _c === void 0 ? void 0 : _c.length) === 0 && group.description) {
                            existingTargetGroup.description = group.description;
                        }
                    }
                });
            }
        });
        // sort groups
        (_a = target.groups) === null || _a === void 0 ? void 0 : _a.forEach((group) => {
            group.children.sort((a, b) => {
                if (a.name > b.name) {
                    return 1;
                }
                else if (a.name === b.name) {
                    return 0;
                }
                return -1;
            });
        });
    }
    /**
     * Copies the group description comment tags into the the given target.
     * @param target The target into which the group descriptions are copied.
     */
    copyGroupDescriptionTagsIntoTarget(target) {
        this.modules.forEach((module) => {
            var _a, _b;
            if (module !== target) {
                const groupDescriptionsOfModule = (_b = (_a = module.comment) === null || _a === void 0 ? void 0 : _a.blockTags.filter((bt) => bt.tag === "@groupDescription")) !== null && _b !== void 0 ? _b : [];
                if (groupDescriptionsOfModule.length === 0) {
                    return; // nothing to copy
                }
                if (!target.comment) {
                    target.comment = new Comment([], []);
                }
                groupDescriptionsOfModule.forEach((groupDescription) => {
                    var _a, _b;
                    const targetModuleAlreadyHasThisGroupDescriptionsTag = (_a = target.comment) === null || _a === void 0 ? void 0 : _a.blockTags.find((bt) => bt.tag === "@groupDescription" &&
                        getNameFromDescriptionTag(bt) === getNameFromDescriptionTag(groupDescription));
                    if (!targetModuleAlreadyHasThisGroupDescriptionsTag) {
                        (_b = target.comment) === null || _b === void 0 ? void 0 : _b.blockTags.push(groupDescription);
                    }
                });
            }
        });
    }
}
