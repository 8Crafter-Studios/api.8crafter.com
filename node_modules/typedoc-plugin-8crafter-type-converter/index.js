import { Converter, ReflectionKind, Application, ReflectionFlags, ReflectionFlag, DefaultThemeRenderContext, PageEvent, JSX, } from "typedoc";
let hasMonkeyPatched = false;
const APIDocsDirectories = `<div class="tsd-theme-toggle">
<label class="settings-label" for="tsd-theme" style="display: inline; position: unset">API for: </label
><select id="tsd-directory" title="The Current API Documentation" onchange="switch(this.value){
    case 'home': window.open('../index.html', '_self'); break;
    case 'andexdb': window.open('../andexdb/index.html', '_self'); break;
}">
    <option value="home">Home</option>
    <option value="andexdb">andexdb</option>
</select>
</div>`;
let currentAPIDocDirectory = "andexdb";

/**
 * 
 * @param {Application} app 
 */
export function load(app) {
    if (hasMonkeyPatched) {
        throw new Error("typedoc-plugin-8crafter-type-converter cannot be loaded multiple times");
    }
    hasMonkeyPatched = true;
    app.options.addDeclaration({
        name: "currentAPIDocDirectory",
        help: "[typedoc-plugin-8crafter-type-converter] Define the current API Doc directory.",
        defaultValue: "andexdb",
    });
    app.converter.on(Converter.EVENT_BEGIN, () => {
        currentAPIDocDirectory = app.options.getValue("currentAPIDocDirectory");
        console.log(app.options.getValue("currentAPIDocDirectory"), currentAPIDocDirectory);
    });
    app.renderer.hooks.on("footer.end", () => {
        return JSX.createElement(JSX.Raw, {html: `<script>
document.getElementById("tsd-toolbar-links").prepend((()=>{let elem = document.createElement(null); elem.innerHTML = ${JSON.stringify(APIDocsDirectories)}; elem.getElementsByTagName("select")[0].value = ${JSON.stringify(currentAPIDocDirectory)}; return elem})());
</script>`})
    });
    app.converter.on(Converter.EVENT_CREATE_DECLARATION, (_context, refl) => {/* 
        if (refl.comment) {
            console.log("8crafter-kind-override-console-log-tags-list" + JSON.stringify([...refl.comment.blockTags].map(c=>c.tag)));
        } */
        if (refl.comment?.getTag("@setexternal")) {
            const tag = refl.comment?.getTag("@setexternal");
            tag.skipRendering = true;
            if(tag.content[0]?.text.startsWith("false")){
                refl.setFlag(ReflectionFlag.External, false);
            }else{
                refl.setFlag(ReflectionFlag.External, true);
            }
        }
        if (refl.comment?.getTag("@setreadonly")) {
            const tag = refl.comment?.getTag("@setreadonly");
            tag.skipRendering = true;
            if(tag.content[0]?.text.startsWith("false")){
                refl.setFlag(ReflectionFlag.Readonly, false);
            }else{
                refl.setFlag(ReflectionFlag.Readonly, true);
            }
        }
        if (refl.comment?.getTag("@setconst")) {
            const tag = refl.comment?.getTag("@setconst");
            tag.skipRendering = true;
            if(tag.content[0]?.text.startsWith("false")){
                refl.setFlag(ReflectionFlag.Const, false);
            }else{
                refl.setFlag(ReflectionFlag.Const, true);
            }
        }
        if (refl.comment?.getTag("@external")) {
            const tag = refl.comment?.getTag("@external");
            tag.skipRendering = true;
            if(tag.content[0]?.text.startsWith("false")){
                refl.setFlag(ReflectionFlag.External, false);
            }else{
                refl.setFlag(ReflectionFlag.External, true);
            }
        }
        if (refl.comment?.getTag("@internal")) {
            refl.setFlag(ReflectionFlag.External, false);
        }
        if (refl.comment?.getTag("@mutable")) {
            const tag = refl.comment?.getTag("@mutable");
            console.log("@mutable declaration tag", tag.name, tag.content.map(c => c.text));
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
        refl.children?.forEach(reflC => {
            if (reflC.comment?.getTag("@mutable")) {
                const tag = reflC.comment?.getTag("@mutable");
                console.log("@mutable declaration child tag", tag.name, tag.content.map(c => c.text));
                // if(tag.name)
                // refl.setFlag(ReflectionFlag.External, true);
            }
        })
        if (refl.comment?.getTag("@kindOverride")) {
            const kindOverrideTag = refl.comment.getTag("@kindOverride");
            kindOverrideTag.skipRendering = true;
            // console.log("8crafter-kind-override-console-log-tags-list" + JSON.stringify(kindOverrideTag.content.map(c => c.text)));
            const kindOverride = kindOverrideTag.content[0]?.text.trim();/* 
            console.log(JSON.stringify({
                numberKind: Number(kindOverride),
                enumKind: ReflectionKind[kindOverride],
                startNumberKind_reflection: refl.kind,
                startEnumKind_reflection: Object.entries(ReflectionKind).find(([key, value]) => value === refl.kind)?.[0],
                startNumberKind_declaration: decl.kind,
                startEnumKind_declaration: Object.entries(SyntaxKind).find(([key, value]) => value === decl.kind)?.[0],
            })); */
            console.log("a1123AA" + refl.parent.name + refl.name + " " + Object.entries(ReflectionKind).find(([key, value]) => value === refl.kind)?.[0] + " " + refl.children?.map(refl=>refl.name + " " + JSON.stringify({signatures: refl.signatures?.length, indexSignatures: refl.indexSignatures?.length, getSignature: !!refl.getSignature, setSignature: !!refl.setSignature}) + " " + JSON.stringify(refl.getNonIndexSignatures().map(s=>[s.name, Object.entries(ReflectionKind).find(([key, value]) => value === s.kind)?.[0]]))).join(", "));
            console.log("a1123AB" + refl.parent.name + refl.name + " " + Object.entries(ReflectionKind).find(([key, value]) => value === refl.kind)?.[0] + " " + refl.children?.map(refl=>refl.name + " " + JSON.stringify(refl.getAllSignatures().map(s=>[s.name, Object.entries(ReflectionKind).find(([key, value]) => value === s.kind)?.[0]]))).join(", "));
            if (/^[0-9]+$/.test(kindOverride)) {
                refl.kind = Number(kindOverride);
                refl.signatures ??= [];
                refl.getNonIndexSignatures().forEach(s=>{
                    if(!refl.signatures.includes(s)){
                        refl.signatures.push(s);
                    }
                });
            } else {
                refl.kind = ReflectionKind[kindOverride];
                refl.signatures ??= [];
                refl.getNonIndexSignatures().forEach(s=>{
                    if(!refl.signatures.includes(s)){
                        refl.signatures.push(s);
                    }
                });
            }
        }
    });
    app.converter.on(Converter.EVENT_RESOLVE, (_context, refl) => {
        if (refl.comment?.getTag("@mutable")) {
            const tag = refl.comment?.getTag("@mutable");
            console.log("@mutable resolved tag", tag.name, tag.content.map(c => c.text));
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
        if (refl.parent?.comment?.getTag("@mutable")) {
            const tag = refl.parent.comment?.getTag("@mutable");
            console.log("@mutable resolved parent tag", tag.name, tag.content.map(c => c.text));
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
    });
    app.converter.on(Converter.EVENT_CREATE_PARAMETER, (_context, refl) => {
        if (refl.comment?.getTag("@mutable")) {
            const tag = refl.comment?.getTag("@mutable");
            console.log("@mutable parameter tag", tag.name, tag.content.map(c => c.text));
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
        if (refl.parent.comment?.getTag("@mutable")) {
            const tag = refl.parent.comment?.getTag("@mutable");
            console.log("@mutable parameter parent tag", tag.name, tag.content.map(c => c.text));
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
    });
    app.converter.on(Converter.EVENT_CREATE_TYPE_PARAMETER, (_context, refl) => {
        if (refl.comment?.getTag("@mutable")) {
            const tag = refl.comment?.getTag("@mutable");
            console.log("@mutable type parameter tag", tag.name, tag.content.map(c => c.text));
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
        if (refl.parent.comment?.getTag("@mutable")) {
            const tag = refl.parent.comment?.getTag("@mutable");
            console.log("@mutable type parameter parent tag", tag.name, tag.content.map(c => c.text));
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
    });
    app.converter.on(Converter.EVENT_CREATE_DOCUMENT, (_context, refl) => {
        if (refl.comment?.getTag("@mutable")) {
            const tag = refl.comment?.getTag("@mutable");
            console.log("@mutable document tag", tag.name, tag.content.map(c => c.text));
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
        if (refl.parent.comment?.getTag("@mutable")) {
            const tag = refl.parent.comment?.getTag("@mutable");
            console.log("@mutable document parent tag", tag.name, tag.content.map(c => c.text));
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
    });
    app.converter.on(Converter.EVENT_CREATE_PROJECT, (_context, refl) => {
        if (refl.comment?.getTag("@mutable")) {
            const tag = refl.comment?.getTag("@mutable");
            console.log("@mutable project tag", tag.name, tag.content.map(c => c.text));
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
        if (refl.parent?.comment?.getTag("@mutable")) {
            const tag = refl.parent.comment?.getTag("@mutable");
            console.log("@mutable project parent tag", tag.name, tag.content.map(c => c.text));
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
    });
    /**
     * @type {Record<ReflectionKind, string[]>}
     */
    // const typesFound = {};
    app.converter.on(Converter.EVENT_CREATE_SIGNATURE, (_context, refl, decl) => {/* 
        if(ReflectionKind[refl.parent.kind] in typesFound) {
            if(!typesFound[ReflectionKind[refl.parent.kind]].includes(ReflectionKind[refl.kind])){
                typesFound[ReflectionKind[refl.parent.kind]].push(ReflectionKind[refl.kind]);
            }
        }else{
            typesFound[ReflectionKind[refl.parent.kind]] = [ReflectionKind[refl.kind]];
        } *//* 
        if(ReflectionKind[refl.parent.kind] in typesFound) {
            if(refl.parent.signatures){
                if((typesFound[ReflectionKind[refl.parent.kind]].signatures ?? 0) < refl.parent.signatures.length){
                    typesFound[ReflectionKind[refl.parent.kind]].signatures = refl.parent.signatures.length;
                }
            }
            if(refl.parent.indexSignatures){
                if((typesFound[ReflectionKind[refl.parent.kind]].indexSignatures ?? 0) < refl.parent.indexSignatures.length){
                    typesFound[ReflectionKind[refl.parent.kind]].indexSignatures = refl.parent.indexSignatures.length;
                }
            }
            if(refl.parent.getSignature){
                if(!typesFound[ReflectionKind[refl.parent.kind]].getSignature){
                    typesFound[ReflectionKind[refl.parent.kind]].getSignature = true;
                }
            }
            if(refl.parent.setSignature){
                if(!typesFound[ReflectionKind[refl.parent.kind]].setSignature){
                    typesFound[ReflectionKind[refl.parent.kind]].setSignature = true;
                }
            }
        }else{
            typesFound[ReflectionKind[refl.parent.kind]] = {
                signatures: refl.parent.signatures?.length,
                indexSignatures: refl.parent.indexSignatures?.length,
                getSignature: !!refl.parent.getSignature,
                setSignature: !!refl.parent.setSignature
            };
        } *//* 
        if (refl.comment) {
            console.log("8crafter-kind-override-console-log-tags-list" + JSON.stringify([...refl.comment.blockTags].map(c=>c.tag)));
        } *//* 
        if (refl.comment) { 
            if(refl.comment.getTag("@kindOverride")) console.log("has kind override tag");
            if(refl.comment.hasModifier("@kindOverride")) console.log("has kind override modifier");
            if(refl.comment.blockTags.map(t=>t.tag).includes("@kindOverride")) console.log("block tags include kind override");
            if([...refl.comment.modifierTags].includes("@kindOverride")) console.log("modifier tags include kind override");
        } */
        if (refl.comment?.getTag("@external")) {
            refl.setFlag(ReflectionFlag.External, true);
        }
        if (refl.comment?.getTag("@internal")) {
            refl.setFlag(ReflectionFlag.External, false);
        }
        if (refl.comment?.getTag("@mutable")) {
            const tag = refl.comment?.getTag("@mutable");
            console.log("@mutable signature tag", tag.name, tag.content.map(c => c.text));
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
        if (refl.parent.comment?.getTag("@mutable")) {
            const tag = refl.parent.comment?.getTag("@mutable");
            console.log("@mutable signature parent tag", tag.name, tag.content.map(c => c.text));
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
        if (refl.comment?.getTag("@kindOverride")) {
            const kindOverrideTag = refl.comment.getTag("@kindOverride");
            kindOverrideTag.skipRendering = true;
            // console.log("8crafter-kind-override-console-log-tags-list" + JSON.stringify(kindOverrideTag.content.map(c=>c.text)));
            const kindOverride = kindOverrideTag.content[0]?.text.trim();/* 
            console.log(JSON.stringify({
                numberKind: Number(kindOverride),
                enumKind: ReflectionKind[kindOverride],
                startNumberKind_reflection: refl.parent.kind,
                startEnumKind_reflection: Object.entries(ReflectionKind).find(([key, value]) => value === refl.parent.kind)?.[0],
                startNumberKind_declaration: decl.kind,
                startEnumKind_declaration: Object.entries(SyntaxKind).find(([key, value]) => value === decl.kind)?.[0],
            })); */
            // console.log(ReflectionKind);
            console.log("a11234BA" + refl.parent.name + " " + refl.name + " " + Object.entries(ReflectionKind).find(([key, value]) => value === refl.parent.kind)?.[0] + " " + JSON.stringify(refl.parent.getNonIndexSignatures().map(s=>[s.name, Object.entries(ReflectionKind).find(([key, value]) => value === s.kind)?.[0]])));
            console.log("a11234BB" + refl.parent.name + " " + refl.name + " " + Object.entries(ReflectionKind).find(([key, value]) => value === refl.parent.kind)?.[0] + " " + JSON.stringify(refl.parent.getAllSignatures().map(s=>[s.name, Object.entries(ReflectionKind).find(([key, value]) => value === s.kind)?.[0]])));
            if (/^[0-9]+$/.test(kindOverride)) {
                refl.kind = Number(kindOverride);
                refl.parent.comment = refl.comment; // Makes the comment appear in cases where it would not normally, but if it starts bugging and duplicating comments, this is probably why.
                refl.parent.signatures ??= [];
                if(!refl.parent.signatures.includes(refl)){
                    refl.parent.signatures.push(refl);
                }
            } else {
                refl.parent.kind = ReflectionKind[kindOverride];
                // refl.kind = ReflectionKind["CallSignature"];
                refl.parent.comment = refl.comment; // Makes the comment appear in cases where it would not normally, but if it starts bugging and duplicating comments, this is probably why.
                refl.parent.signatures ??= [];
                if(!refl.parent.signatures.includes(refl)){
                    refl.parent.signatures.push(refl);
                }
                // refl.parent.getSignature = undefined;
                // console.log(refl.parent.getAllSignatures());
                // console.log(refl.parent.getFullName());
                // refl.parent.kind = 4096;
                // decl.kind = 262;
                // console.log(refl.kind, decl.kind);
            }
        }
    });/* 
    setTimeout(() => {
        console.log(typesFound);
    }, 10000); */
}

/**
 * Kind Notes
 * Project: 
 * Module: Opens in own page. Does not show details on current page.
 * Namespace: Opens in own page. Does not show details on current page.
 * Enum: Opens in own page.
 * EnumMember: Details must be displayed on current page.
 * Variable: Opens in own page. If a getter is converted to this, comments will NOT show. If a property is converted to this, comments will show, but the type definition will be complete blank.
 * Function: Opens in own page.
 * Class: Opens in own page. Shows details on current page.
 * Interface: Opens in own page.
 * Constructor: Details must be displayed on current page.
 * Property: Details must be displayed on current page.
 * Method: Details must be displayed on current page.
 * CallSignature: 
 * IndexSignature: 
 * ConstructorSignature: 
 * Parameter: Details must be displayed on current page.
 * TypeLiteral: ? If a getter is converted to this, it will not have its own page, and clicking it will just reload the current page.
 * TypeParameter: Details must be displayed on current page.
 * Accessor: Details must be displayed on current page.
 * GetSignature: Details must be displayed on current page.
 * SetSignature: Details must be displayed on current page.
 * TypeAlias: Opens in own page. If a getter is converted to this, comments will NOT show.
 * Reference: 
 * Document: 
 */