// prettier-include
import { readFileSync } from "node:fs";
import { Converter, ReflectionKind, Application, ReflectionFlags, ReflectionFlag, DefaultThemeRenderContext, PageEvent, JSX } from "typedoc";
let hasMonkeyPatched = false;
const APIDocsDirectories = `<label class="settings-label" for="tsd-theme" style="display: inline; position: unset">API for: </label
><select id="tsd-directory" title="The Current API Documentation" onchange="switch(this.value){
    case 'home': window.open('../index.html', '_self'); break;
    case 'andexdb': window.open('../andexdb/stable/index.html', '_self'); break;
}">
    <option value="home">Home</option>
    <option value="andexdb">andexdb</option>
</select>`;
let currentAPIDocDirectory = "andexdb";

/**
 * @type {ts.Symbol[]}
 */
globalThis.parentOverriddenExportedMissingExportSymbols = globalThis.parentOverriddenExportedMissingExportSymbols ?? [];

/**
 * @type {ts.Symbol[]}
 */
globalThis.parentOverriddenExportedMissingExportSymbolsWithResolveFailures = globalThis.parentOverriddenExportedMissingExportSymbolsWithResolveFailures ?? [];

/**
 * @type {Map<ts.Symbol, {friendly: string, full: string}>}
 */
globalThis.symbolToHierarchy = globalThis.symbolToHierarchy ?? new Map();

/**
 *
 * @param {Application} app
 */
export async function load(app) {
    if (hasMonkeyPatched) {
        throw new Error("typedoc-plugin-8crafter-type-converter cannot be loaded multiple times");
    }
    hasMonkeyPatched = true; /* 
    app.converter.on(Converter.EVENT_END, async (_context) => {
        const fileName = `./${_context.project.name}`;
        await app.generateJson(_context.project, fileName);
        const data = readFileSync(fileName, "utf-8");
    }) */
    app.options.addDeclaration({
        name: "currentAPIDocDirectory",
        help: "[typedoc-plugin-8crafter-type-converter] Define the current API Doc directory.",
        defaultValue: "andexdb",
    });
    if (!!!app.options.getDeclaration("invalidParentOverrideModule"))
        app.options.addDeclaration({
            name: "invalidParentOverrideModule",
            help: "[typedoc-plugin-missing-exports] Define the name of the module that internal symbols which fail to have the value of their @parentOverride tags resolved should be placed into.",
            defaultValue: "<invalid_parent_override>",
        });
    if (!!!app.options.getDeclaration("rootModuleParentOverrideName"))
        app.options.addDeclaration({
            name: "rootModuleParentOverrideName",
            help: "[typedoc-plugin-missing-exports] Define the name to specify in a symbol's @parentOverride tag to place it in the root module.",
            defaultValue: ":root:",
        });
    if (!!!app.options.getDeclaration("missingCurrentScopeModule"))
        app.options.addDeclaration({
            name: "missingCurrentScopeModule",
            help: "[typedoc-plugin-missing-exports] Define the name of the module that internal symbols which fail to resolve their current scopes when given the @useCurrentScopeAsParent tag should be placed into.",
            defaultValue: "<useCurrentScopeAsParent_missing_current_scope>",
        });
    app.converter.on(Converter.EVENT_BEGIN, () => {
        app.options.setValue(
            "blockTags",
            [
                ...new Set([
                    ...app.options.getValue("blockTags"),
                    "@useCurrentScopeAsParent",
                    "@parentOverride",
                    "@nameOverride",
                    "@kindOverride",
                    "@setexternal",
                    "@setreadonly",
                    "@setconst",
                    "@external",
                    "@mutable",
                ]),
            ],
            "../../typedoc_andexdb.json"
        );
        currentAPIDocDirectory = app.options.getValue("currentAPIDocDirectory");
        app.converter.addUnknownSymbolResolver((symbol) => {
            console.log({moduleSource: symbol.moduleSource, resolutionStart: symbol.resolutionStart, symbolReference: {path: JSON.stringify(symbol.symbolReference?.path.map(p=>[p.navigation, p.path])), meaning: symbol.symbolReference?.meaning}});
        })
    });
    app.renderer.hooks.on("footer.end", () => {
        return JSX.createElement(JSX.Raw, {
            html: `<script>
    function addExtraOptions() {
        const elem1 = document.createElement("div");
        elem1.classList.add("tsd-theme-toggle");
        elem1.innerHTML = ${JSON.stringify(APIDocsDirectories)};
        const elem1_select = elem1.getElementsByTagName("select")[0];
        elem1_select.value = ${JSON.stringify(currentAPIDocDirectory)}; 
        const elem2 = elem1.cloneNode(true);
        const elem2_select = elem2.getElementsByTagName("select")[0];
        elem2_select.id = "tsd-directory-sidebar";
        elem2_select.value = ${JSON.stringify(currentAPIDocDirectory)}; 
        elem2.getElementsByTagName("label")[0].setAttribute("for", "tsd-directory-sidebar");
        elem1.classList.add("only-visible-on-non-mobile-sidebar");
        elem2.classList.add("only-visible-on-mobile-sidebar");
        document.getElementById("tsd-toolbar-links").prepend(elem1);
        document.getElementById("tsd-sidebar-links").prepend(elem2);
    }
    addExtraOptions();
</script>`,
        });
    });
    app.converter.on(Converter.EVENT_CREATE_DECLARATION, (_context, refl) => {
        /* 
        if (refl.comment) {
            console.log("8crafter-kind-override-console-log-tags-list" + JSON.stringify([...refl.comment.blockTags].map(c=>c.tag)));
        } */
        if (refl.comment?.getTag("@parentOverride")) {
            const parentOverrideTag = refl.comment.getTag("@parentOverride");
            parentOverrideTag.skipRendering = true;
            const symbol = _context.project.getSymbolFromReflection(refl);
            if (parentOverriddenExportedMissingExportSymbols.includes(symbol) && !refl.comment?.getTag("@parentOverrideDouble")) {
                if (parentOverriddenExportedMissingExportSymbolsWithResolveFailures.includes(symbol)) {
                    const parentOverride = parentOverrideTag.content[0]?.text.trim();
                    app.logger.warn(`Unable to resolve @parentOverride reference: ${JSON.stringify(parentOverride)} for ${JSON.stringify(symbolToHierarchy.get(symbol).friendly + "." + refl.name)}`);
                }
                console.log(`${refl.getFullName()} has already been parent overridden by [typedoc-plugin-missing-exports-8crafter-edition]. Skipping...`);
            } else {
                const modules = _context.project.getChildrenByKind(ReflectionKind.Module);
                const mod = modules.find((m) => _context.scope.getFullName().startsWith(m.name + "."));
                if (true/* modules.length === 0 */) { // Modified to force the internal module to be created, even when there are other modules.
                    // Single entry point, just target the project.
                    modules.push(_context.project);
                }
                const parentOverride = parentOverrideTag.content[0]?.text.trim();
                const invalidParentOverrideNS = _context
                    .withScope(mod)
                    .createDeclarationReflection(ReflectionKind.Module, void 0, void 0, app.options.getValue("invalidParentOverrideModule"));
                let newParent =
                    parentOverride === app.options.getValue("rootModuleParentOverrideName") ?
                        _context.project
                    :   (_context.project.getChildByName(parentOverride) ??
                        _context.project.getChildByName(
                            (modules.find((m) => !!_context.project.getChildByName(m.name + "." + parentOverride))?.name ??
                                modules.find((m) => !!_context.project.getChildByName(m.escapedName + "." + parentOverride))?.name) + "." + parentOverride
                        ));
                if (!!!newParent) {
                    app.logger.warn(`Unable to resolve @parentOverride reference: ${JSON.stringify(parentOverride)} for ${JSON.stringify(refl.getFullName())}`);
                    newParent = invalidParentOverrideNS;
                }
                console.log(
                    "@parentOverride",
                    "DECLARATION",
                    parentOverride,
                    JSON.stringify(
                        {
                            url: refl.url,
                            name: refl.name,
                            escapedName: refl.escapedName,
                            fullName: refl.getFullName(),
                            friendlyFullName: refl.getFriendlyFullName(),
                            parent: refl.parent?.name,
                            parentEscapedName: refl.parent?.escapedName,
                            parentFullName: refl.parent?.getFullName(),
                            parentFriendlyFullName: refl.parent?.getFriendlyFullName(),
                            newParent: newParent?.name,
                            newParentEscapedName: newParent?.escapedName,
                            newParentFullName: newParent?.getFullName(),
                            newParentFriendlyFullName: newParent?.getFriendlyFullName(),
                        },
                        undefined,
                        4
                    )
                );
                refl.parent = newParent;
                console.log(
                    "@parentOverride",
                    "DECLARATION_AFTER",
                    parentOverride,
                    JSON.stringify(
                        {
                            url: refl.url,
                            name: refl.name,
                            escapedName: refl.escapedName,
                            fullName: refl.getFullName(),
                            friendlyFullName: refl.getFriendlyFullName(),
                            parent: refl.parent?.name,
                            parentEscapedName: refl.parent?.escapedName,
                            parentFullName: refl.parent?.getFullName(),
                            parentFriendlyFullName: refl.parent?.getFriendlyFullName(),
                            newParent: newParent?.name,
                            newParentEscapedName: newParent?.escapedName,
                            newParentFullName: newParent?.getFullName(),
                            newParentFriendlyFullName: newParent?.getFriendlyFullName(),
                        },
                        undefined,
                        4
                    )
                );
            }
        }
        if (refl.comment?.getTag("@useCurrentScopeAsParent")) {
            const newScope = _context.scope.getFullName();
            refl.parent = _context.project.getChildByName(newScope);
        }
        if (refl.comment?.getTag("@setexternal")) {
            const tag = refl.comment?.getTag("@setexternal");
            tag.skipRendering = true;
            if (tag.content[0]?.text.startsWith("false")) {
                refl.setFlag(ReflectionFlag.External, false);
            } else {
                refl.setFlag(ReflectionFlag.External, true);
            }
        }
        if (refl.comment?.getTag("@setreadonly")) {
            const tag = refl.comment?.getTag("@setreadonly");
            tag.skipRendering = true;
            if (tag.content[0]?.text.startsWith("false")) {
                refl.setFlag(ReflectionFlag.Readonly, false);
            } else {
                refl.setFlag(ReflectionFlag.Readonly, true);
            }
        }
        if (refl.comment?.getTag("@setconst")) {
            const tag = refl.comment?.getTag("@setconst");
            tag.skipRendering = true;
            if (tag.content[0]?.text.startsWith("false")) {
                refl.setFlag(ReflectionFlag.Const, false);
            } else {
                refl.setFlag(ReflectionFlag.Const, true);
            }
        }
        if (refl.comment?.getTag("@external")) {
            const tag = refl.comment?.getTag("@external");
            tag.skipRendering = true;
            if (tag.content[0]?.text.startsWith("false")) {
                refl.setFlag(ReflectionFlag.External, false);
            } else {
                refl.setFlag(ReflectionFlag.External, true);
            }
        }
        if (refl.comment?.getTag("@internal")) {
            refl.setFlag(ReflectionFlag.External, false);
        }/* 
        if (refl.comment?.getTag("@mutable")) {
            const tag = refl.comment?.getTag("@mutable");
            console.log(
                "@mutable declaration tag",
                tag.name,
                tag.content.map((c) => c.text)
            );
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        } *//* 
        refl.children?.forEach((reflC) => {
            if (reflC.comment?.getTag("@mutable")) {
                const tag = reflC.comment?.getTag("@mutable");
                console.log(
                    "@mutable declaration child tag",
                    tag.name,
                    tag.content.map((c) => c.text)
                );
                // if(tag.name)
                // refl.setFlag(ReflectionFlag.External, true);
            }
        });  *//* 
        if (refl.comment?.getTag("@returnTypeOverride")) {
            const returnTypeOverrideTag = refl.comment.getTag("@returnTypeOverride");
            returnTypeOverrideTag.skipRendering = true;
            const returnTypeOverride = returnTypeOverrideTag.content[0]?.text.trim();
            console.log("@returnTypeOverride", returnTypeOverride, refl.type);
        } */
        if (refl.comment?.getTag("@nameOverride")) {
            const nameOverrideTag = refl.comment.getTag("@nameOverride");
            nameOverrideTag.skipRendering = true;
            const nameOverride = nameOverrideTag.content[0]?.text.trim();
            /* console.log(
                "@nameOverride",
                "DECLARATION",
                nameOverride,
                JSON.stringify({
                    name: refl.name,
                    escapedName: refl.escapedName,
                    fullName: refl.getFullName(),
                    friendlyFullName: refl.getFriendlyFullName(),
                })
            ); */
            refl.name = nameOverride;
        }
        if (refl.comment?.getTag("@kindOverride")) {
            const kindOverrideTag = refl.comment.getTag("@kindOverride");
            kindOverrideTag.skipRendering = true;
            // console.log("8crafter-kind-override-console-log-tags-list" + JSON.stringify(kindOverrideTag.content.map(c => c.text)));
            const kindOverride = kindOverrideTag.content[0]?.text.trim(); /* 
            console.log(JSON.stringify({
                numberKind: Number(kindOverride),
                enumKind: ReflectionKind[kindOverride],
                startNumberKind_reflection: refl.kind,
                startEnumKind_reflection: Object.entries(ReflectionKind).find(([key, value]) => value === refl.kind)?.[0],
                startNumberKind_declaration: decl.kind,
                startEnumKind_declaration: Object.entries(SyntaxKind).find(([key, value]) => value === decl.kind)?.[0],
            })); */
            /* console.log(
                "a1123AA" +
                    refl.parent.name +
                    refl.name +
                    " " +
                    Object.entries(ReflectionKind).find(([key, value]) => value === refl.kind)?.[0] +
                    " " +
                    refl.children
                        ?.map(
                            (refl) =>
                                refl.name +
                                " " +
                                JSON.stringify({
                                    signatures: refl.signatures?.length,
                                    indexSignatures: refl.indexSignatures?.length,
                                    getSignature: !!refl.getSignature,
                                    setSignature: !!refl.setSignature,
                                }) +
                                " " +
                                JSON.stringify(
                                    refl
                                        .getNonIndexSignatures()
                                        .map((s) => [s.name, Object.entries(ReflectionKind).find(([key, value]) => value === s.kind)?.[0]])
                                )
                        )
                        .join(", ")
            ); */
            /* console.log(
                "a1123AB" +
                    refl.parent.name +
                    refl.name +
                    " " +
                    Object.entries(ReflectionKind).find(([key, value]) => value === refl.kind)?.[0] +
                    " " +
                    refl.children
                        ?.map(
                            (refl) =>
                                refl.name +
                                " " +
                                JSON.stringify(
                                    refl.getAllSignatures().map((s) => [s.name, Object.entries(ReflectionKind).find(([key, value]) => value === s.kind)?.[0]])
                                )
                        )
                        .join(", ")
            ); */
            if (/^[0-9]+$/.test(kindOverride)) {
                refl.kind = Number(kindOverride);
                refl.signatures ??= [];
                refl.getNonIndexSignatures().forEach((s) => {
                    if (!refl.signatures.includes(s)) {
                        refl.signatures.push(s);
                    }
                });
            } else {
                refl.kind = ReflectionKind[kindOverride];
                refl.signatures ??= [];
                refl.getNonIndexSignatures().forEach((s) => {
                    if (!refl.signatures.includes(s)) {
                        refl.signatures.push(s);
                    }
                });
            }
        }
    });
    app.converter.on(Converter.EVENT_RESOLVE, (_context, refl) => {
        if (refl.comment?.getTag("@mutable")) {
            const tag = refl.comment?.getTag("@mutable");
            console.log(
                "@mutable resolved tag",
                tag.name,
                tag.content.map((c) => c.text)
            );
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
        if (refl.parent?.comment?.getTag("@mutable")) {
            const tag = refl.parent.comment?.getTag("@mutable");
            console.log(
                "@mutable resolved parent tag",
                tag.name,
                tag.content.map((c) => c.text)
            );
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        } /* 
        if (refl.comment?.getTag("@parentOverride")) {
            const parentOverrideTag = refl.comment.getTag("@parentOverride");
            parentOverrideTag.skipRendering = true;
            const parentOverride = parentOverrideTag.content[0]?.text.trim();
            const newParent = _context.project.getChildByName("Globals.config");
            console.log("@parentOverride", "RESOLVE", parentOverride, JSON.stringify({
                url: refl.url,
                name: refl.name,
                escapedName: refl.escapedName,
                fullName: refl.getFullName(),
                friendlyFullName: refl.getFriendlyFullName(),
                parent: refl.parent?.name,
                parentEscapedName: refl.parent?.escapedName,
                parentFullName: refl.parent?.getFullName(),
                parentFriendlyFullName: refl.parent?.getFriendlyFullName(),
                newParent: newParent?.name,
                newParentEscapedName: newParent?.escapedName,
                newParentFullName: newParent?.getFullName(),
                newParentFriendlyFullName: newParent?.getFriendlyFullName(),
            }, undefined, 4));
            refl.parent = newParent;
            console.log("@parentOverride", "RESOLVE_AFTER", parentOverride, JSON.stringify({
                url: refl.url,
                name: refl.name,
                escapedName: refl.escapedName,
                fullName: refl.getFullName(),
                friendlyFullName: refl.getFriendlyFullName(),
                parent: refl.parent?.name,
                parentEscapedName: refl.parent?.escapedName,
                parentFullName: refl.parent?.getFullName(),
                parentFriendlyFullName: refl.parent?.getFriendlyFullName(),
                newParent: newParent?.name,
                newParentEscapedName: newParent?.escapedName,
                newParentFullName: newParent?.getFullName(),
                newParentFriendlyFullName: newParent?.getFriendlyFullName(),
            }, undefined, 4));
        } */
    });
    app.converter.on(Converter.EVENT_CREATE_PARAMETER, (_context, refl) => {
        if (refl.comment?.getTag("@mutable")) {
            const tag = refl.comment?.getTag("@mutable");
            console.log(
                "@mutable parameter tag",
                tag.name,
                tag.content.map((c) => c.text)
            );
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
        if (refl.parent.comment?.getTag("@mutable")) {
            const tag = refl.parent.comment?.getTag("@mutable");
            console.log(
                "@mutable parameter parent tag",
                tag.name,
                tag.content.map((c) => c.text)
            );
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
    });
    app.converter.on(Converter.EVENT_CREATE_TYPE_PARAMETER, (_context, refl) => {
        if (refl.comment?.getTag("@mutable")) {
            const tag = refl.comment?.getTag("@mutable");
            console.log(
                "@mutable type parameter tag",
                tag.name,
                tag.content.map((c) => c.text)
            );
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
        if (refl.parent.comment?.getTag("@mutable")) {
            const tag = refl.parent.comment?.getTag("@mutable");
            console.log(
                "@mutable type parameter parent tag",
                tag.name,
                tag.content.map((c) => c.text)
            );
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
    });
    app.converter.on(Converter.EVENT_CREATE_DOCUMENT, (_context, refl) => {
        if (refl.comment?.getTag("@mutable")) {
            const tag = refl.comment?.getTag("@mutable");
            console.log(
                "@mutable document tag",
                tag.name,
                tag.content.map((c) => c.text)
            );
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
        if (refl.parent.comment?.getTag("@mutable")) {
            const tag = refl.parent.comment?.getTag("@mutable");
            console.log(
                "@mutable document parent tag",
                tag.name,
                tag.content.map((c) => c.text)
            );
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
    });
    app.converter.on(Converter.EVENT_CREATE_PROJECT, (_context, refl) => {
        if (refl.comment?.getTag("@mutable")) {
            const tag = refl.comment?.getTag("@mutable");
            console.log(
                "@mutable project tag",
                tag.name,
                tag.content.map((c) => c.text)
            );
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
        if (refl.parent?.comment?.getTag("@mutable")) {
            const tag = refl.parent.comment?.getTag("@mutable");
            console.log(
                "@mutable project parent tag",
                tag.name,
                tag.content.map((c) => c.text)
            );
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
    });
    /**
     * @type {Record<ReflectionKind, string[]>}
     */
    // const typesFound = {};
    app.converter.on(Converter.EVENT_CREATE_SIGNATURE, (_context, refl, decl) => {
        /* 
        if(ReflectionKind[refl.parent.kind] in typesFound) {
            if(!typesFound[ReflectionKind[refl.parent.kind]].includes(ReflectionKind[refl.kind])){
                typesFound[ReflectionKind[refl.parent.kind]].push(ReflectionKind[refl.kind]);
            }
        }else{
            typesFound[ReflectionKind[refl.parent.kind]] = [ReflectionKind[refl.kind]];
        } */ /* 
        if(ReflectionKind[refl.parent.kind] in typesFound) {
            if(refl.parent.signatures){
                if((typesFound[ReflectionKind[refl.parent.kind]].signatures ?? 0) < refl.parent.signatures.length){
                    typesFound[ReflectionKind[refl.parent.kind]].signatures = refl.parent.signatures.length;
                }
            }
            if(refl.parent.indexSignatures){
                if((typesFound[ReflectionKind[refl.parent.kind]].indexSignatures ?? 0) < refl.parent.indexSignatures.length){
                    typesFound[ReflectionKind[refl.parent.kind]].indexSignatures = refl.parent.indexSignatures.length;
                }
            }
            if(refl.parent.getSignature){
                if(!typesFound[ReflectionKind[refl.parent.kind]].getSignature){
                    typesFound[ReflectionKind[refl.parent.kind]].getSignature = true;
                }
            }
            if(refl.parent.setSignature){
                if(!typesFound[ReflectionKind[refl.parent.kind]].setSignature){
                    typesFound[ReflectionKind[refl.parent.kind]].setSignature = true;
                }
            }
        }else{
            typesFound[ReflectionKind[refl.parent.kind]] = {
                signatures: refl.parent.signatures?.length,
                indexSignatures: refl.parent.indexSignatures?.length,
                getSignature: !!refl.parent.getSignature,
                setSignature: !!refl.parent.setSignature
            };
        } */ /* 
        if (refl.comment) {
            console.log("8crafter-kind-override-console-log-tags-list" + JSON.stringify([...refl.comment.blockTags].map(c=>c.tag)));
        } */ /* 
        if (refl.comment) { 
            if(refl.comment.getTag("@kindOverride")) console.log("has kind override tag");
            if(refl.comment.hasModifier("@kindOverride")) console.log("has kind override modifier");
            if(refl.comment.blockTags.map(t=>t.tag).includes("@kindOverride")) console.log("block tags include kind override");
            if([...refl.comment.modifierTags].includes("@kindOverride")) console.log("modifier tags include kind override");
        } */
        if (refl.comment?.getTag("@external")) {
            refl.setFlag(ReflectionFlag.External, true);
        }
        if (refl.comment?.getTag("@internal")) {
            refl.setFlag(ReflectionFlag.External, false);
        }
        if (refl.comment?.getTag("@mutable")) {
            const tag = refl.comment?.getTag("@mutable");
            console.log(
                "@mutable signature tag",
                tag.name,
                tag.content.map((c) => c.text)
            );
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        }
        if (refl.parent.comment?.getTag("@mutable")) {
            const tag = refl.parent.comment?.getTag("@mutable");
            console.log(
                "@mutable signature parent tag",
                tag.name,
                tag.content.map((c) => c.text)
            );
            // if(tag.name)
            // refl.setFlag(ReflectionFlag.External, true);
        } /* 
        if (refl.comment?.getTag("@returnTypeOverride")) {
            const returnTypeOverrideTag = refl.comment.getTag("@returnTypeOverride");
            returnTypeOverrideTag.skipRendering = true;
            const returnTypeOverride = returnTypeOverrideTag.content[0]?.text.trim();
            // console.log("@returnTypeOverride", returnTypeOverride, refl.type);
        } */
        if (refl.comment?.getTag("@nameOverride")) {
            const nameOverrideTag = refl.comment.getTag("@nameOverride");
            nameOverrideTag.skipRendering = true;
            const nameOverride = nameOverrideTag.content[0]?.text.trim();
            console.log(
                "@nameOverride",
                "SIGNATURE",
                nameOverride,
                JSON.stringify({
                    name: refl.name,
                    escapedName: refl.escapedName,
                    fullName: refl.getFullName(),
                    friendlyFullName: refl.getFriendlyFullName(),
                })
            );
            refl.name = nameOverride;
        }
        if (refl.comment?.getTag("@kindOverride")) {
            const kindOverrideTag = refl.comment.getTag("@kindOverride");
            kindOverrideTag.skipRendering = true;
            // console.log("8crafter-kind-override-console-log-tags-list" + JSON.stringify(kindOverrideTag.content.map(c=>c.text)));
            const kindOverride = kindOverrideTag.content[0]?.text.trim(); /* 
            console.log(JSON.stringify({
                numberKind: Number(kindOverride),
                enumKind: ReflectionKind[kindOverride],
                startNumberKind_reflection: refl.parent.kind,
                startEnumKind_reflection: Object.entries(ReflectionKind).find(([key, value]) => value === refl.parent.kind)?.[0],
                startNumberKind_declaration: decl.kind,
                startEnumKind_declaration: Object.entries(SyntaxKind).find(([key, value]) => value === decl.kind)?.[0],
            })); */
            // console.log(ReflectionKind);
            /* console.log(
                "a11234BA" +
                    refl.parent.name +
                    " " +
                    refl.name +
                    " " +
                    Object.entries(ReflectionKind).find(([key, value]) => value === refl.parent.kind)?.[0] +
                    " " +
                    JSON.stringify(
                        refl.parent.getNonIndexSignatures().map((s) => [s.name, Object.entries(ReflectionKind).find(([key, value]) => value === s.kind)?.[0]])
                    )
            ); */
            /* console.log(
                "a11234BB" +
                    refl.parent.name +
                    " " +
                    refl.name +
                    " " +
                    Object.entries(ReflectionKind).find(([key, value]) => value === refl.parent.kind)?.[0] +
                    " " +
                    JSON.stringify(
                        refl.parent.getAllSignatures().map((s) => [s.name, Object.entries(ReflectionKind).find(([key, value]) => value === s.kind)?.[0]])
                    )
            ); */
            if (/^[0-9]+$/.test(kindOverride)) {
                refl.kind = Number(kindOverride);
                refl.parent.comment = refl.comment; // Makes the comment appear in cases where it would not normally, but if it starts bugging and duplicating comments, this is probably why.
                refl.parent.signatures ??= [];
                if (!refl.parent.signatures.includes(refl)) {
                    refl.parent.signatures.push(refl);
                }
            } else {
                refl.parent.kind = ReflectionKind[kindOverride];
                // refl.kind = ReflectionKind["CallSignature"];
                refl.parent.comment = refl.comment; // Makes the comment appear in cases where it would not normally, but if it starts bugging and duplicating comments, this is probably why.
                refl.parent.signatures ??= [];
                if (!refl.parent.signatures.includes(refl)) {
                    refl.parent.signatures.push(refl);
                }
                // refl.parent.getSignature = undefined;
                // console.log(refl.parent.getAllSignatures());
                // console.log(refl.parent.getFullName());
                // refl.parent.kind = 4096;
                // decl.kind = 262;
                // console.log(refl.kind, decl.kind);
            }
        }
    }); /* 
    setTimeout(() => {
        console.log(typesFound);
    }, 10000); */
}

/**
 * Kind Notes
 * Project:
 * Module: Opens in own page. Does not show details on current page.
 * Namespace: Opens in own page. Does not show details on current page.
 * Enum: Opens in own page.
 * EnumMember: Details must be displayed on current page.
 * Variable: Opens in own page. If a getter is converted to this, comments will NOT show. If a property is converted to this, comments will show, but the type definition will be complete blank.
 * Function: Opens in own page.
 * Class: Opens in own page. Shows details on current page.
 * Interface: Opens in own page.
 * Constructor: Details must be displayed on current page.
 * Property: Details must be displayed on current page.
 * Method: Details must be displayed on current page.
 * CallSignature:
 * IndexSignature:
 * ConstructorSignature:
 * Parameter: Details must be displayed on current page.
 * TypeLiteral: ? If a getter is converted to this, it will not have its own page, and clicking it will just reload the current page.
 * TypeParameter: Details must be displayed on current page.
 * Accessor: Details must be displayed on current page.
 * GetSignature: Details must be displayed on current page.
 * SetSignature: Details must be displayed on current page.
 * TypeAlias: Opens in own page. If a getter is converted to this, comments will NOT show.
 * Reference:
 * Document:
 */
