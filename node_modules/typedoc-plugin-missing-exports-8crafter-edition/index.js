import { relative } from "path";
import { Converter, ReflectionKind, TypeScript as ts, ReferenceType, ParameterType, JSX, Renderer, Application, DeclarationReflection, Context, } from "typedoc";
let hasMonkeyPatched = false;
const ModuleLike = ReflectionKind.Project | ReflectionKind.Module;
const InternalModule = Symbol();
const HOOK_JS = `
<script>for (let k in localStorage) if (k.includes("tsd-accordion-") && k.includes(NAME)) localStorage.setItem(k, "false");</script>
`.trim();

/**
 * @type {ts.Symbol[]}
 */
globalThis.parentOverriddenExportedMissingExportSymbols = globalThis.parentOverriddenExportedMissingExportSymbols ?? [];

/**
 * @type {ts.Symbol[]}
 */
globalThis.parentOverriddenExportedMissingExportSymbolsWithResolveFailures = globalThis.parentOverriddenExportedMissingExportSymbolsWithResolveFailures ?? [];

/**
 * @type {Map<ts.Symbol, {friendly: string, full: string}>}
 */
globalThis.symbolToHierarchy = globalThis.symbolToHierarchy ?? new Map();


/**
 * The main entry point for the plugin.
 * @param {Application} app 
 */
export function load(app) {
    if (hasMonkeyPatched) {
        throw new Error("typedoc-plugin-missing-exports cannot be loaded multiple times");
    }
    hasMonkeyPatched = true;
    /**
     * @type {Map<ts.Program, Set<ts.Symbol>>}
     */
    const referencedSymbols = new Map();
    const symbolToOwningModule = new Map();
    const knownPrograms = new Map();
    /**
     * 
     * @param {DeclarationReflection} owningModule 
     * @param {Context} context 
     * @param {import("typescript").Program} program 
     * @returns {Set<ts.Symbol>}
     */
    function discoverMissingExports(owningModule, context, program) {
        // An export is missing if if was referenced
        // Is not contained in the documented
        const referenced = referencedSymbols.get(program) || new Set();
        const ownedByOther = new Set();
        referencedSymbols.set(program, ownedByOther);
        for (const s of [...referenced]) {
            if (context.project.getReflectionFromSymbol(s)) {
                referenced.delete(s);
            }
            else if (symbolToOwningModule.get(s) !== owningModule) {
                referenced.delete(s);
                ownedByOther.add(s);
            }
        }
        return referenced;
    }
    // Monkey patch the constructor for references so that we can get every
    const origCreateSymbolReference = ReferenceType.createSymbolReference;
    ReferenceType.createSymbolReference = function (symbol, context, name) {
        const owningModule = getOwningModule(context);
        const set = referencedSymbols.get(context.program);
        symbolToOwningModule.set(symbol, owningModule);
        symbolToHierarchy.set(symbol, {friendly: context.scope.getFriendlyFullName(), full: context.scope.getFullName()});
        if (set) {
            set.add(symbol);
        }
        else {
            referencedSymbols.set(context.program, new Set([symbol]));
        }
        return origCreateSymbolReference.call(this, symbol, context, name);
    };
    app.options.addDeclaration({
        name: "internalModule",
        help: "[typedoc-plugin-missing-exports] Define the name of the module that internal symbols which are not exported should be placed into.",
        defaultValue: "<internal>",
    });
    app.options.addDeclaration({
        name: "collapseInternalModule",
        help: "[typedoc-plugin-missing-exports] Include JS in the page to collapse all <internal> entries in the navigation on page load.",
        defaultValue: false,
        type: ParameterType.Boolean,
    });
    app.options.addDeclaration({
        name: "placeInternalsInOwningModule",
        help: "[typedoc-plugin-missing-exports] If set internal symbols will not be placed into an internals module, but directly into the module which references them.",
        defaultValue: false,
        type: ParameterType.Boolean,
    });
    if (!!!app.options.getDeclaration("invalidParentOverrideModule"))
        app.options.addDeclaration({
            name: "invalidParentOverrideModule",
            help: "[typedoc-plugin-missing-exports] Define the name of the module that internal symbols which fail to have the value of their @parentOverride tags resolved should be placed into.",
            defaultValue: "<invalid_parent_override>",
        });
    if (!!!app.options.getDeclaration("missingCurrentScopeModule"))
        app.options.addDeclaration({
            name: "missingCurrentScopeModule",
            help: "[typedoc-plugin-missing-exports] Define the name of the module that internal symbols which fail to resolve their current scopes when given the @useCurrentScopeAsParent tag should be placed into.",
            defaultValue: "<useCurrentScopeAsParent_missing_current_scope>",
        });
    if(!!!app.options.getDeclaration("rootModuleParentOverrideName")) app.options.addDeclaration({
        name: "rootModuleParentOverrideName",
        help: "[typedoc-plugin-missing-exports] Define the name to specify in a symbol's @parentOverride tag to place it in the root module.",
        defaultValue: ":root:",
    });
    app.converter.on(Converter.EVENT_BEGIN, () => {
        if (app.options.getValue("placeInternalsInOwningModule") &&
            app.options.isSet("internalModule")) {
            app.logger.warn(`[typedoc-plugin-missing-exports] Both placeInternalsInOwningModule and internalModule are set, the internalModule option will be ignored.`);
        }
    });
    app.converter.on(Converter.EVENT_CREATE_DECLARATION, (context, refl) => {
        if (refl.comment?.getTag("@parentOverride")) {
            // console.log("returning before overriding declaration with @parentOverride tag to be <internal> module");
            return;
        }
        // TypeDoc 0.26 doesn't fire EVENT_CREATE_DECLARATION for project
        // We need to ensure the project has a program attached to it, so
        // do that when the first declaration is created.
        if (knownPrograms.size === 0) {
            knownPrograms.set(refl.project, context.program);
        }
        if (refl.kindOf(ModuleLike)) {
            knownPrograms.set(refl, context.program);
        }
        // #12 - This plugin might cause TypeDoc to convert some module without
        // an export symbol to give it a name other than the full absolute
        // path to the symbol. Detect this and rename it to a relative path
        // based on base path if specified or CWD.
        const symbol = context.project.getSymbolFromReflection(refl);
        const file = symbol?.declarations?.find(ts.isSourceFile);
        if (file && /^".*"$/.test(refl.name)) {
            refl.name = getModuleName(file.fileName, app.options.getValue("basePath") || process.cwd());
        }
    });
    app.converter.on(Converter.EVENT_RESOLVE_BEGIN, function onResolveBegin(context) {
        const modules = context.project.getChildrenByKind(ReflectionKind.Module);
        if (true/* modules.length === 0 */) { // Modified to force the internal module to be created, even when there are other modules.
            // Single entry point, just target the project.
            modules.push(context.project);
        }
        for (const mod of modules) {
            const program = knownPrograms.get(mod);
            if (!program)
                continue;
            let missing = discoverMissingExports(mod, context, program);
            if (!missing.size)
                continue;
            // Nasty hack here that will almost certainly break in future TypeDoc versions.
            context.setActiveProgram(program);
            let internalContext;
            if (app.options.getValue("placeInternalsInOwningModule")) {
                internalContext = context.withScope(mod);
            }
            else {
                const internalNs = context
                    .withScope(mod)
                    .createDeclarationReflection(ReflectionKind.Module, void 0, void 0, app.options.getValue("internalModule"));
                internalNs[InternalModule] = true;
                context.finalizeDeclarationReflection(internalNs);
                internalContext = context.withScope(internalNs);
            }
            const invalidParentOverrideNS = context
                .withScope(mod)
                .createDeclarationReflection(ReflectionKind.Module, void 0, void 0, app.options.getValue("invalidParentOverrideModule"));
            const missingCurrentScopeNS = context
                .withScope(mod)
                .createDeclarationReflection(ReflectionKind.Module, void 0, void 0, app.options.getValue("missingCurrentScopeModule"));
            // Keep track of which symbols we've tried to convert. If they don't get converted
            // when calling convertSymbol, then the user has excluded them somehow, don't go into
            // an infinite loop when converting.
            const tried = new Set();
            do {
                for (const s of missing) {
                    if (shouldConvertSymbol(s, context.checker)) {
                        // This was added by 8Crafter.
                        const parentOverrideTag = s.getJsDocTags().find(t => t.name === "parentOverride");
                        if (parentOverrideTag) {
                            console.log("parentOverride tag: " + s.name, s.getEscapedName().__escapedIdentifier);
                            /**
                             * @type {string | undefined}
                             */
                            let parentOverride = parentOverrideTag?.text?.[0]?.text.trim().replace(/:[a-zA-Z]+$/, "");
                            /**
                             * @type {string | null}
                             */
                            let parentOverrideKindFilter = parentOverrideTag?.text?.[0]?.text.trim().match(/:([a-zA-Z]+)$/, "")?.[1];
                            /**
                             * @type {keyof typeof ReflectionKind | null}
                             */
                            let parentOverringReflectionKind = parentOverrideKindFilter != null ? Object.keys(ReflectionKind).find(k=>k.toLowerCase() === parentOverrideKindFilter.toLowerCase()) : null;
                            let newParent = parentOverride === app.options.getValue("rootModuleParentOverrideName") ? context.project : context.project.getChildByName(parentOverride) ??
                                context.project.getChildByName(
                                    (
                                        modules.find(m =>
                                            !!context.project.getChildByName(m.name + "." + parentOverride)
                                        )?.name ?? modules.find(m =>
                                            !!context.project.getChildByName(m.escapedName + "." + parentOverride)
                                        )?.name
                                    ) + "." + parentOverride
                                );
                            if(!!!newParent) {
                                parentOverriddenExportedMissingExportSymbolsWithResolveFailures.push(s);
                                newParent = invalidParentOverrideNS;
                            }else if (parentOverringReflectionKind !== null) {
                                let done = false;
                                newParent.parent.traverse((r) => {
                                    if (done) return;
                                    if (r.kind === ReflectionKind[parentOverringReflectionKind] && parentOverride.includes(r.name)) {
                                        done = true;
                                        newParent = r;
                                    }
                                })
                            }
                            parentOverriddenExportedMissingExportSymbols.push(s);
                            context.converter.convertSymbol(context.withScope(newParent), s);
                            // console.log("using over convert type to prevent overriding declaration with @parentOverride tag to be <internal> module: " + JSON.stringify(s.name) + ", " + JSON.stringify(s.escapedName) + ", " + JSON.stringify(context.project.name) + ", " + JSON.stringify(newParent.name));
                        } else {
                            const useCurrentScopeAsParentTag = s.getJsDocTags().find(t => t.name === "useCurrentScopeAsParent");
                            if (useCurrentScopeAsParentTag) {
                                console.log("useCurrentScopeAsParent tag: " + s.name, s.getEscapedName().__escapedIdentifier);
                                const newScope = context.project.getChildByName(symbolToHierarchy.get(s).full) ?? context.project.getChildByName(symbolToHierarchy.get(s).full.split(".").slice(0, -1).join(".")) ?? missingCurrentScopeNS;
                                parentOverriddenExportedMissingExportSymbols.push(s);
                                context.converter.convertSymbol(context.withScope(newScope), s);
                            } else {
                                internalContext.converter.convertSymbol(internalContext, s);
                            }
                        }
                    }
                    tried.add(s);
                }
                missing = discoverMissingExports(mod, context, program);
                for (const s of tried) {
                    missing.delete(s);
                }
            } while (missing.size > 0);
            // If we added a module and all the missing symbols were excluded, get rid of our namespace.
            if (internalContext.scope[InternalModule] &&
                !internalContext.scope.children?.length) {
                context.project.removeReflection(internalContext.scope);
            }
            if (!context.withScope(invalidParentOverrideNS).scope.children?.length) {
                context.project.removeReflection(invalidParentOverrideNS);
            }
            if (!context.withScope(missingCurrentScopeNS).scope.children?.length) {
                context.project.removeReflection(missingCurrentScopeNS);
            }
            context.setActiveProgram(void 0);
        }
        knownPrograms.clear();
        referencedSymbols.clear();
        symbolToOwningModule.clear();
    }, 1e9);
    app.renderer.on(Renderer.EVENT_BEGIN, () => {
        if (app.options.getValue("collapseInternalModule")) {
            app.renderer.hooks.on("head.end", () => JSX.createElement(JSX.Raw, {
                html: HOOK_JS.replace("NAME", JSON.stringify(app.options.getValue("internalModule"))),
            }));
        }
    });
}
/**
 * 
 * @param {Context} context 
 * @returns {Reflection}
 */
function getOwningModule(context) {
    let refl = context.scope;/* 
    if (refl.comment?.getTag("@parentOverride")) {
        return refl.parent;
    } */
    // Go up the reflection hierarchy until we get to a module
    while (!refl.kindOf(ModuleLike)) {
        refl = refl.parent;
    }
    // The <internal> module cannot be an owning module.
    if (refl[InternalModule]) {
        return refl.parent;
    }
    return refl;
}
/**
 * 
 * @param {ts.Symbol} symbol 
 * @param {ts.TypeChecker} checker 
 * @returns 
 */
function shouldConvertSymbol(symbol, checker) {
    while (symbol.flags & ts.SymbolFlags.Alias) {
        symbol = checker.getAliasedSymbol(symbol);
    }
    // We're looking at an unknown symbol which is declared in some package without
    // type declarations. We know nothing about it, so don't convert it.
    if (symbol.flags & ts.SymbolFlags.Transient) {
        return false;
    }
    // This is something inside the special Node `Globals` interface. Don't convert it
    // because TypeDoc will reasonably assert that "Property" means that a symbol should be
    // inside something that can have properties.
    if (symbol.flags & ts.SymbolFlags.Property && symbol.name !== "default") {
        return false;
    }
    return true;
}
function getModuleName(fileName, baseDir) {
    return relative(baseDir, fileName)
        .replace(/\\/g, "/")
        .replace(/(\/index)?(\.d)?\.([cm]?[tj]s|[tj]sx?)$/, "");
}
//# sourceMappingURL=index.js.map